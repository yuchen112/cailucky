<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Memory Match</title>
<style>
  :root{
    --bg0:#0b1220; --bg1:#111b2e;
    --panel: rgba(255,255,255,.06);
    --panel2: rgba(255,255,255,.09);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.65);
    --shadow: 0 18px 50px rgba(0,0,0,.45);
    --radius: 22px;
    --gap: 10px;
    --tileSize: 76px;
    --tileRadius: 18px;
    --tileBackA: rgba(255,255,255,.10);
    --tileBackB: rgba(255,255,255,.06);
    --tileFront: rgba(255,255,255,.10);
    --tileFront2: rgba(255,255,255,.06);
    --tileStroke: rgba(255,255,255,.14);
    --glow: rgba(120,180,255,.18);
    --accent: #7aa7ff;
    --emojiSize: calc(var(--tileSize) * .55);
  }

    /* Card styles (ÁâåÈù¢È¢®Ê†ºÔºöÂè™ÂΩ±ÈüøÂç°ÁâåÊùêË≥™/ÈÇäÊ°Ü/ÂÖâÊæ§Ôºå‰∏çÊîπÊï¥È´îËâ≤Ë™ø) */
  body[data-card="soft"]{
    --tileStroke: rgba(255,255,255,.14);
    --tileBackA: rgba(255,255,255,.10);
    --tileBackB: rgba(255,255,255,.06);
    --tileFront: rgba(255,255,255,.10);
    --tileFront2: rgba(255,255,255,.06);
  }
  body[data-card="neon"]{
    --tileStroke: rgba(255,255,255,.18);
    --tileBackA: rgba(105,240,255,.14);
    --tileBackB: rgba(0,0,0,.06);
    --tileFront: rgba(255,255,255,.10);
    --tileFront2: rgba(0,0,0,.06);
    --glow: rgba(105,240,255,.22);
  }
  body[data-card="bold"]{
    --tileStroke: rgba(255,255,255,.16);
    --tileBackA: rgba(255,255,255,.12);
    --tileBackB: rgba(255,255,255,.07);
    --tileFront: rgba(255,255,255,.12);
    --tileFront2: rgba(255,255,255,.07);
  }

  /* Color tones (Ëâ≤Ë™øÔºöÂΩ±ÈüøËÉåÊôØ/‰∏ªËâ≤Ôºå‰∏çÂΩ±ÈüøÁâåÈù¢È¢®Ê†º) */
  body[data-tone="ocean"]{ --accent:#7aa7ff; --bg0:#0b1220; --bg1:#111b2e; --glow: rgba(122,167,255,.18); }
  body[data-tone="mint"] { --accent:#57f0c8; --bg0:#071a17; --bg1:#0b2b25; --glow: rgba(87,240,200,.18); }
  body[data-tone="grape"]{ --accent:#b08cff; --bg0:#120a1f; --bg1:#27124a; --glow: rgba(176,140,255,.18); }
  body[data-tone="sunset"]{ --accent:#ff8a5c; --bg0:#180a0a; --bg1:#3a1212; --glow: rgba(255,138,92,.18); }
  body[data-tone="mono"]{ --accent:#cfd6e6; --bg0:#0c1018; --bg1:#151b24; --glow: rgba(207,214,230,.12); }

  /* Appearance (‰∫Æ/ÊöóÊ®°Âºè) */
  body[data-mode="light"]{
    --panel: rgba(0,0,0,.05);
    --panel2: rgba(0,0,0,.08);
    --text: rgba(10,15,25,.92);
    --muted: rgba(10,15,25,.62);
    --shadow: 0 18px 50px rgba(0,0,0,.18);
    /* light background takes tone but shifts to paper */
    background:
      radial-gradient(1200px 900px at 20% 10%, rgba(255,255,255,.85), transparent 55%),
      radial-gradient(1000px 700px at 85% 25%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1200px 900px at 50% 100%, rgba(0,0,0,.08), transparent 60%),
      linear-gradient(180deg, color-mix(in srgb, var(--accent) 6%, #ffffff), #f4f6fb);
  }


  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
    color:var(--text);
    background:
      radial-gradient(1200px 900px at 20% 10%, rgba(255,255,255,.08), transparent 55%),
      radial-gradient(1000px 700px at 85% 25%, rgba(255,255,255,.06), transparent 60%),
      radial-gradient(1200px 900px at 50% 100%, rgba(0,0,0,.55), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg0));
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    overscroll-behavior: none;
    -webkit-tap-highlight-color: transparent;
  }

  .app{
    width:min(980px, 100%);
    border-radius: calc(var(--radius) + 10px);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    border: 1px solid rgba(255,255,255,.12);
    overflow:hidden;
    position:relative;
  }

  .vignette{
    position:absolute; inset:-1px;
    pointer-events:none;
    background: radial-gradient(900px 600px at 50% 15%, transparent 0 55%, rgba(0,0,0,.45) 100%);
    mix-blend-mode: multiply;
    opacity:.65;
  }

  header{
    display:flex;
    gap:12px;
    align-items:flex-start;
    justify-content:space-between;
    padding:14px 14px 10px;
  }

  .title{
    display:flex; flex-direction:column; gap:4px;
  }
  .title h1{
    margin:0;
    font-size:16px;
    letter-spacing:.2px;
    font-weight:800;
  }
  .title .sub{
    font-size:12px;
    color:var(--muted);
  }

  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    justify-content:flex-end;
    align-items:center;
  }

  .pill{
    display:flex;
    gap:8px;
    align-items:center;
    background: rgba(255,255,255,.07);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 999px;
    padding:8px 10px;
    backdrop-filter: blur(10px);
  }
  label{
    font-size:12px;
    color:var(--muted);
    user-select:none;
    white-space:nowrap;
  }
  select, button{
    font:inherit;
  }
  select{
    border:1px solid rgba(255,255,255,.16);
    background: rgba(0,0,0,.18);
    color:var(--text);
    border-radius: 10px;
    padding:6px 8px;
    font-size:12px;
    outline:none;
  }
  button{
    border:1px solid rgba(255,255,255,.16);
    background: rgba(0,0,0,.18);
    color:var(--text);
    border-radius: 12px;
    padding:8px 10px;
    font-size:12px;
    cursor:pointer;
    user-select:none;
    transition: transform .08s ease, background .15s ease, border-color .15s ease;
  }
  button.primary{
    background: color-mix(in srgb, var(--accent) 18%, rgba(0,0,0,.18));
    border-color: color-mix(in srgb, var(--accent) 40%, rgba(255,255,255,.16));
  }
  button:active{ transform: scale(.98); }
  button:disabled{ opacity:.55; cursor:not-allowed; }

  .stats{
    display:flex;
    gap:10px;
    align-items:center;
    padding:0 14px 12px;
    color:var(--muted);
    font-size:12px;
  }
  .stats b{ color:var(--text); font-weight:800; }

  .boardWrap{
    padding: 0 14px 16px;
  }

  .boardPanel{
    border-radius: calc(var(--radius) + 4px);
    background: linear-gradient(180deg, rgba(0,0,0,.20), rgba(0,0,0,.10));
    border: 1px solid rgba(255,255,255,.10);
    padding: 14px;
    position:relative;
    overflow:hidden;
  }
  .boardPanel::before{
    content:"";
    position:absolute; inset:-80px;
    background:
      radial-gradient(900px 600px at 15% 10%, var(--glow), transparent 60%),
      radial-gradient(700px 450px at 90% 30%, rgba(255,255,255,.05), transparent 65%);
    filter: blur(2px);
    opacity:.9;
    pointer-events:none;
  }

  .board{
    position:relative;
    display:grid;
    gap: var(--gap);
    justify-content:center;
    align-content:center;
    touch-action: manipulation;
  }

  .lock{
    position:absolute; inset:0;
    background: rgba(0,0,0,.22);
    backdrop-filter: blur(2px);
    display:none;
    align-items:center;
    justify-content:center;
    color: rgba(255,255,255,.85);
    font-size:13px;
    letter-spacing:.2px;
    z-index:5;
  }
  .lock.show{ display:flex; }

  /* Win overlay */
  .win{
    position:fixed; inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    padding:24px;
    background: rgba(0,0,0,.45);
    backdrop-filter: blur(6px);
    z-index:50;
  }
  body[data-mode="light"] .win{ background: rgba(0,0,0,.28); }
  .win.show{ display:flex; }
  .winCard{
    width:min(420px, 92vw);
    border-radius: 18px;
    padding:18px 18px 14px;
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    border:1px solid rgba(255,255,255,.16);
    box-shadow: 0 18px 60px rgba(0,0,0,.35);
    text-align:center;
    position:relative;
    overflow:hidden;
  }
  body[data-mode="light"] .winCard{
    background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.82));
    border:1px solid rgba(0,0,0,.08);
  }
  .winTitle{
    margin-top:10px;
    font-weight: 850;
    letter-spacing:.5px;
    font-size: 22px;
  }
  .winMeta{
    margin-top:8px;
    font-size:13px;
    color: rgba(255,255,255,.78);
  }
  body[data-mode="light"] .winMeta{ color: rgba(0,0,0,.60); }
  .winBtns{
    margin-top:14px;
    display:flex;
    gap:10px;
    justify-content:center;
    flex-wrap:wrap;
  }
  .btn{
    appearance:none;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.08);
    color: rgba(255,255,255,.92);
    padding:10px 14px;
    border-radius: 14px;
    font-weight: 700;
    cursor:pointer;
    transition: transform .12s ease, filter .12s ease, background .12s ease;
  }
  body[data-mode="light"] .btn{
    border:1px solid rgba(0,0,0,.10);
    background: rgba(0,0,0,.04);
    color: rgba(0,0,0,.78);
  }
  .btn.primary{
    background: color-mix(in srgb, var(--accent) 26%, rgba(255,255,255,.10));
    border-color: rgba(255,255,255,.26);
  }
  body[data-mode="light"] .btn.primary{
    background: color-mix(in srgb, var(--accent) 22%, rgba(255,255,255,.92));
    border-color: rgba(0,0,0,.08);
  }
  .btn:active{ transform: translateY(1px) scale(.99); }

  .winAnim{
    width:74px; height:74px;
    margin: 6px auto 0;
    position:relative;
  }
  .winAnim .ring{
    position:absolute; inset:0;
    border-radius:50%;
    border:3px solid rgba(255,255,255,.18);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
    animation: popIn .32s cubic-bezier(.2,.8,.2,1) both;
  }
  body[data-mode="light"] .winAnim .ring{ border-color: rgba(0,0,0,.10); }
  .winAnim .tick{
    position:absolute;
    width:28px; height:14px;
    border-left:6px solid color-mix(in srgb, var(--accent) 80%, white);
    border-bottom:6px solid color-mix(in srgb, var(--accent) 80%, white);
    transform: rotate(-45deg);
    left: 22px; top: 26px;
    border-radius:2px;
    animation: tick .42s .10s cubic-bezier(.2,.9,.2,1) both;
  }
  @keyframes popIn{
    from{ transform: scale(.7); opacity:.0; }
    to{ transform: scale(1); opacity:1; }
  }
  @keyframes tick{
    from{ transform: rotate(-45deg) scale(.5); opacity:0; }
    to{ transform: rotate(-45deg) scale(1); opacity:1; }
  }

  .confetti{
    position:absolute;
    inset:0;
    overflow:hidden;
    pointer-events:none;
  }
  .confetti i{
    position:absolute;
    width:8px; height:14px;
    border-radius:3px;
    opacity:.0;
    transform: translateY(-30px) rotate(0deg);
    animation: confetti 1.1s ease-in forwards;
  }
  @keyframes confetti{
    0%{ opacity:0; transform: translateY(-30px) rotate(0deg); }
    15%{ opacity:1; }
    100%{ opacity:0; transform: translateY(520px) rotate(520deg); }
  }


  .tile{
    width: var(--tileSize);
    height: var(--tileSize);
    perspective: 900px;
    border-radius: var(--tileRadius);
  }
  .inner{
    width:100%; height:100%;
    position:relative;
    transform-style: preserve-3d;
    transition: transform .28s cubic-bezier(.2,.8,.2,1);
    border-radius: inherit;
  }
  .tile.revealed .inner,
  .tile.matched .inner{
    transform: rotateY(180deg);
  }

  .face{
    position:absolute; inset:0;
    border-radius: inherit;
    backface-visibility:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    border: 1px solid var(--tileStroke);
    overflow:hidden;
  }

  /* card BACK (before flip) */
  .front{
    background: linear-gradient(180deg, var(--tileFront), var(--tileFront2));
  }
  .front::before{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.14), transparent 45%),
      radial-gradient(120% 120% at 70% 80%, rgba(0,0,0,.20), transparent 55%);
    opacity:.9;
  }
  .front::after{
    content:"";
    position:absolute; inset:10%;
    border-radius: calc(var(--tileRadius) - 6px);
    border:1px solid rgba(255,255,255,.12);
    opacity:.9;
  }
  .badge{
    width: 46%;
    height: 46%;
    border-radius: 14px;
    background: linear-gradient(135deg, rgba(255,255,255,.14), rgba(0,0,0,.10));
    border: 1px solid rgba(255,255,255,.16);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.12);
    transform: rotate(10deg);
    opacity:.9;
  }

  /* card FACE (after flip) */
  .back{
    transform: rotateY(180deg);
    background: linear-gradient(180deg, var(--tileBackA), var(--tileBackB));
  }

  .symbol{
    font-size: var(--emojiSize);
    line-height: 1;
    filter: drop-shadow(0 6px 14px rgba(0,0,0,.25));
    user-select:none;
  }

  /* poker coloration */
  .symbol.poker.red{ color: rgba(255,90,110,.95); }
  .symbol.poker.black{ color: rgba(255,255,255,.92); }

  .tile:not(.revealed):not(.matched):hover .inner{
    /* ONLY subtle hint, NO flip */
    transform: translateY(-1px);
  }
  .tile:not(.revealed):not(.matched) .inner{
    box-shadow: 0 10px 24px rgba(0,0,0,.25);
  }
  .tile:not(.revealed):not(.matched):active .inner{
    transform: translateY(0) scale(.99);
  }

  .tile.matched .face{
    border-color: color-mix(in srgb, var(--accent) 55%, rgba(255,255,255,.16));
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 25%, transparent);
  }

  /* poker deck: add subtle corner pips on BACK face only */
  .tile[data-deck="poker"] .back::before{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(circle at 16% 18%, rgba(255,255,255,.10) 0 18%, transparent 19%),
      radial-gradient(circle at 84% 82%, rgba(255,255,255,.08) 0 16%, transparent 17%);
    opacity:.6;
  }

  @media (max-width: 560px){
    header{ flex-direction:column; align-items:stretch; }
    .controls{ justify-content:flex-start; }
  }
</style>
</head>
<body data-card="soft" data-tone="ocean" data-mode="dark">
  <div class="app">
    <div class="vignette"></div>

    <header>
      <div class="title">
        <h1>Memory Match</h1>
        <div class="sub">ÈªûÊìäÁøªÁâåÈÖçÂ∞çÔºåÈ†êË¶ΩÊ®°ÂºèÊúÉÂÖàÂÖ®Áøª 2 Áßí</div>
      </div>

      <div class="controls">
        <div class="pill">
          <label for="cardSel">ÁâåÈù¢È¢®Ê†º</label>
          <select id="cardSel">
            <option value="soft">ÊüîÂíå</option>
            <option value="neon">ÈúìËôπ</option>
            <option value="bold">ÈÆÆÊòé</option>
          </select>
        </div>

        <div class="pill">
          <label for="toneSel">Ëâ≤Ë™ø</label>
          <select id="toneSel">
            <option value="ocean">Êµ∑Ê¥ã</option>
            <option value="mint">ËñÑËç∑</option>
            <option value="grape">Ëë°ËêÑ</option>
            <option value="sunset">Â§ïÈôΩ</option>
            <option value="mono">ÈªëÁôΩ</option>
          </select>
        </div>

        <div class="pill">
          <label for="themeSel">Ê®°Âºè</label>
          <select id="themeSel">
            <option value="dark">ÊöóËâ≤</option>
            <option value="light">‰∫ÆËâ≤</option>
          </select>
        </div>

        <div class="pill">
          <label for="deckSel">ÁâåÂ∫´</label>
          <select id="deckSel">
            <option value="faces">Ë°®ÊÉÖ</option>
            <option value="animals">ÂãïÁâ©</option>
            <option value="plants">Ëä±Ëçâ</option>
           
            <option value="poker">Êí≤ÂÖãÁâå</option>
          </select>
        </div>

        <div class="pill">
          <label for="sizeSel">Â§ßÂ∞è</label>
          <select id="sizeSel">
            <option value="4">4√ó4</option>
            <option value="6">6√ó6</option>
            <option value="8">8√ó8</option>
          </select>
        </div>

        <div class="pill">
          <label for="modeSel">ÈñãÂ±Ä</label>
          <select id="modeSel">
            <option value="preview">ÂÖ®Áøª 2 Áßí</option>
            <option value="direct">Áõ¥Êé•Áé©</option>
          </select>
        </div>

        <button id="startBtn" class="primary">ÈñãÂßã</button>
        <button id="restartBtn">ÈáçÈñã</button>
      </div>
    </header>

    <div class="stats">
      Ê≠•Êï∏ <b id="moves">0</b>„ÄÄ
      Â∑≤ÈÖçÂ∞ç <b id="matched">0</b>/<span id="pairs">0</span>„ÄÄ
      ÊôÇÈñì <b id="time">0.0</b>s
    </div>

    <div class="boardWrap">
      <div class="boardPanel">
        <div id="lock" class="lock">È†êË¶Ω‰∏≠‚Ä¶</div>
        <div id="board" class="board" aria-label="memory board"></div>
        <div id="win" class="win" aria-hidden="true">
          <div class="winCard" role="dialog" aria-modal="true" aria-label="win">
            <div class="winAnim">
              <div class="ring"></div>
              <div class="tick"></div>
            </div>
            <div class="winTitle">ÈÅéÈóú</div>
            <div id="winMeta" class="winMeta"></div>
            <div class="winBtns">
              <button id="winAgain" class="btn primary" type="button">ÂÜçÁé©‰∏ÄÊ¨°</button>
              <button id="winClose" class="btn" type="button">ÈóúÈñâ</button>
            </div>
          </div>
          <div class="confetti" aria-hidden="true"></div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  const LS_KEY = "memory_match_clean_v2";
  const $ = (id) => document.getElementById(id);

  const cardSel = $("cardSel");
  const toneSel = $("toneSel");
  const themeSel = $("themeSel");
  const deckSel = $("deckSel");
  const sizeSel = $("sizeSel");
  const modeSel = $("modeSel");
  const startBtn = $("startBtn");
  const restartBtn = $("restartBtn");
  const boardEl = $("board");
  const lockEl = $("lock");

  const winEl = $("win");
  const winMetaEl = $("winMeta");
  const winAgainBtn = $("winAgain");
  const winCloseBtn = $("winClose");

  const movesEl = $("moves");
  const matchedEl = $("matched");
  const pairsEl = $("pairs");
  const timeEl = $("time");

  const DECKS = {
    faces: ["üòÄ","üòé","ü•∂","ü§Ø","ü•≥","ü•π","üòÇ","üòç","ü§ñ","üòà","üëª","ü§†","üò∫","üôÉ","üò¥","ü§©","üò°","üò≠","üò±","üòá","üòÖ","ü•≤","ü´£","ü´°","ü§®","ü§ë","ü§°","üíÄ","üëΩ","üò∫","üòπ","üòª","üôÄ","üòø","üòæ","ü´†","üò§","üòµ‚Äçüí´","ü§î","ü§≠","ü•∫","üòÆ‚Äçüí®","üò¥","ü´•","ü•∏","üò§","ü§ê","ü§¢","ü§Æ","ü§ß","üò∑","ü´®","üòµ"],
    animals: ["üê∂","üê±","üê≠","üêπ","üê∞","ü¶ä","üêª","üêº","üê®","üêØ","ü¶Å","üêÆ","üê∑","üê∏","üêµ","üêî","üêß","üê¶","üê§","ü¶Ü","ü¶â","ü¶á","üê∫","üêó","üê¥","ü¶Ñ","üêù","ü™≤","ü¶ã","üêå","üêû","üê¢","üêç","ü¶é","ü¶Ç","ü¶Ä","üêô","üê†","üêü","üê¨","ü¶à","üê≥","ü¶≠","ü¶¶","ü¶•","ü¶î","üêò","ü¶í","ü¶ì","ü¶¨","üêë","üêê","ü¶å","üêï","üêà","ü¶ú","ü¶¢","ü¶©"],
    plants: ["üå∏","üåº","üåª","üå∑","üåø","üçÄ","üçÅ","üçÇ","üçÉ","üåπ","ü•Ä","üå∫","üåª","üåµ","üå≥","üå≤","üå¥","üéã","ü™µ","ü™ª","üåæ","üçÑ","üå±","‚òòÔ∏è","üåø","üçÉ","üçÄ","üå∏","üåº","üå∑","ü™∑","üå∫","üåπ","ü•Ä","üåª","üåæ","üçÅ","üçÇ","üçÉ","üåµ","üå≤","üå≥","üå¥"],
    poker: (() => {
      const suits = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
      const ranks = ["A","K","Q","J","10","9","8","7","6","5","4","3","2"];
      const out = [];
      for (const s of suits){
        for (const r of ranks){
          out.push(r + s);
        }
      }
      return out; // 52
    })()
  };

  let state = null;

  function savePrefs(){
    const prefs = {
      card: cardSel.value,
      tone: toneSel.value,
      theme: themeSel.value,
      deck: deckSel.value,
      size: sizeSel.value,
      mode: modeSel.value
    };
    localStorage.setItem(LS_KEY, JSON.stringify(prefs));
  }

  function loadPrefs(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const p = JSON.parse(raw);
      if(p && typeof p === "object"){
        if(p.card) cardSel.value = p.card;
        if(p.tone) toneSel.value = p.tone;
        if(p.theme) themeSel.value = p.theme;
        if(p.deck) deckSel.value = p.deck;
        if(p.size) sizeSel.value = p.size;
        if(p.mode) modeSel.value = p.mode;
      }
    }catch{}
  }

  function applyAppearance(){
    document.body.setAttribute("data-card", cardSel.value);
    document.body.setAttribute("data-tone", toneSel.value);
    document.body.setAttribute("data-mode", themeSel.value);
  }

  function computeMetrics(size){
    const panel = boardEl.parentElement; // boardPanel
    const cs = getComputedStyle(document.documentElement);
    const gap = parseFloat(cs.getPropertyValue("--gap")) || 10;
    const pad = 14; // boardPanel padding
    const w = panel.clientWidth - pad*2;
    const usable = Math.max(260, Math.min(w, 860));
    const tile = Math.floor((usable - gap*(size-1)) / size);
    const tileSize = Math.max(44, Math.min(tile, 120));
    document.documentElement.style.setProperty("--tileSize", tileSize + "px");
    document.documentElement.style.setProperty("--tileRadius", Math.max(12, Math.round(tileSize*0.22)) + "px");
    document.documentElement.style.setProperty("--emojiSize", Math.round(tileSize*0.58) + "px");
    boardEl.style.gridTemplateColumns = `repeat(${size}, var(--tileSize))`;
  }

  function shuffled(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function buildDeck(deckKey, pairs){
    const src = DECKS[deckKey] || DECKS.faces;
    const uniq = shuffled(src).slice(0, pairs);
    const cards = shuffled([...uniq, ...uniq]);
    return cards;
  }

  function isPokerRed(sym){
    return sym.includes("‚ô•") || sym.includes("‚ô¶");
  }

  function renderBoard(){
    const size = Number(sizeSel.value);
    const pairs = (size*size)/2;
    pairsEl.textContent = String(pairs);

    computeMetrics(size);

    boardEl.innerHTML = "";
    const deckKey = deckSel.value;
    const cards = buildDeck(deckKey, pairs);

    state = {
      size, pairs,
      deckKey,
      cards,
      revealed: [],
      matchedCount: 0,
      moves: 0,
      timeStart: null,
      timer: null,
      locked: true,
      allowInput: false
    };

    for(let i=0;i<cards.length;i++){
      const sym = cards[i];
      const tile = document.createElement("button");
      tile.type = "button";
      tile.className = "tile";
      tile.setAttribute("aria-label", "card");
      tile.dataset.index = String(i);
      tile.dataset.deck = deckKey;

      const inner = document.createElement("div");
      inner.className = "inner";

      const front = document.createElement("div");
      front.className = "face front";
      const badge = document.createElement("div");
      badge.className = "badge";
      front.appendChild(badge);

      const back = document.createElement("div");
      back.className = "face back";
      const span = document.createElement("div");
      span.className = "symbol" + (deckKey==="poker" ? " poker " + (isPokerRed(sym) ? "red":"black") : "");
      span.textContent = sym;
      back.appendChild(span);

      inner.append(front, back);
      tile.appendChild(inner);
      boardEl.appendChild(tile);
    }

    boardEl.addEventListener("click", onBoardClick, { passive: true });

    updateStats();
    applyInputLock(true, "ready");
  }

  function updateStats(){
    movesEl.textContent = String(state?.moves ?? 0);
    matchedEl.textContent = String(state?.matchedCount ?? 0);
  }

  function applyInputLock(isLocked, reason){
    if(!state) return;
    state.allowInput = !isLocked;
    lockEl.classList.toggle("show", isLocked && reason === "preview");
    // Hard lock pointer events during preview only
    boardEl.style.pointerEvents = isLocked ? "none" : "auto";
  }

  function startTimer(){
    if(state.timer) clearInterval(state.timer);
    state.timeStart = performance.now();
    state.timer = setInterval(() => {
      const t = (performance.now() - state.timeStart)/1000;
      timeEl.textContent = t.toFixed(1);
    }, 100);
  }

  function stopTimer(){
    if(state?.timer){
      clearInterval(state.timer);
      state.timer = null;
    }
  }

  function clearConfetti(){
    const c = winEl?.querySelector(".confetti");
    if(c) c.innerHTML = "";
  }

  function burstConfetti(){
    const c = winEl?.querySelector(".confetti");
    if(!c) return;
    c.innerHTML = "";
    const n = 26;
    for(let i=0;i<n;i++){
      const p = document.createElement("i");
      const left = Math.random()*100;
      const delay = Math.random()*0.10;
      const dur = 0.95 + Math.random()*0.35;
      p.style.left = left.toFixed(2) + "%";
      p.style.top = (-20 - Math.random()*40).toFixed(0) + "px";
      p.style.animationDelay = delay.toFixed(2) + "s";
      p.style.animationDuration = dur.toFixed(2) + "s";
      // color from accent + two neutrals
      const r = Math.random();
      let col;
      if(r < 0.55){
        col = getComputedStyle(document.body).getPropertyValue("--accent").trim() || "#6ee7d8";
      }else if(r < 0.80){
        col = "rgba(255,255,255,.70)";
      }else{
        col = "rgba(0,0,0,.25)";
      }
      p.style.background = col;
      p.style.transform = "translateY(-30px) rotate(" + (Math.random()*120) + "deg)";
      c.appendChild(p);
    }
  }

  function showWin(){
    if(!winEl) return;
    const t = state?.timeStart ? ((performance.now() - state.timeStart)/1000) : 0;
    winMetaEl.textContent = `ÊôÇÈñì ${t.toFixed(1)}sÔºåÊ≠•Êï∏ ${state.moves}ÔºåÈÖçÂ∞ç ${state.matchedCount}/${state.pairs}`;
    winEl.classList.add("show");
    winEl.setAttribute("aria-hidden","false");
    burstConfetti();
  }

  function hideWin(){
    if(!winEl) return;
    winEl.classList.remove("show");
    winEl.setAttribute("aria-hidden","true");
    clearConfetti();
  }


  function startGame(){
    savePrefs();
    applyAppearance();
    hideWin();
    renderBoard();

    // preview logic
    const mode = modeSel.value;
    timeEl.textContent = "0.0";
    stopTimer();
    state.moves = 0;
    state.matchedCount = 0;
    state.revealed = [];
    updateStats();

    if(mode === "preview"){
      // reveal all briefly, but LOCK input
      applyInputLock(true, "preview");
      const tiles = [...boardEl.querySelectorAll(".tile")];
      tiles.forEach(t => t.classList.add("revealed"));
      setTimeout(() => {
        tiles.forEach(t => t.classList.remove("revealed"));
        applyInputLock(false, "ready");
        startTimer();
      }, 2000);
    }else{
      applyInputLock(false, "ready");
      startTimer();
    }
  }

  function restartGame(){
    if(!state) return startGame();
    // rebuild with same settings
    startGame();
  }

  function onBoardClick(e){
    if(!state || !state.allowInput) return;
    const tile = e.target.closest(".tile");
    if(!tile) return;

    const idx = Number(tile.dataset.index);
    if(Number.isNaN(idx)) return;

    if(tile.classList.contains("matched") || tile.classList.contains("revealed")) return;
    if(state.revealed.length >= 2) return;

    tile.classList.add("revealed");
    state.revealed.push(idx);

    if(state.revealed.length === 2){
      state.moves += 1;
      updateStats();
      const [a,b] = state.revealed;
      const sa = state.cards[a];
      const sb = state.cards[b];

      // temporarily lock further clicks until resolve
      state.allowInput = false;
      boardEl.style.pointerEvents = "none";

      if(sa === sb){
        setTimeout(() => {
          const ta = boardEl.querySelector(`.tile[data-index="${a}"]`);
          const tb = boardEl.querySelector(`.tile[data-index="${b}"]`);
          ta?.classList.add("matched");
          tb?.classList.add("matched");
          state.matchedCount += 1;
          state.revealed = [];
          updateStats();

          state.allowInput = true;
          boardEl.style.pointerEvents = "auto";

          if(state.matchedCount === state.pairs){
            stopTimer();
            applyInputLock(true, "win");
            showWin();
          }
        }, 220);
      }else{
        setTimeout(() => {
          const ta = boardEl.querySelector(`.tile[data-index="${a}"]`);
          const tb = boardEl.querySelector(`.tile[data-index="${b}"]`);
          ta?.classList.remove("revealed");
          tb?.classList.remove("revealed");
          state.revealed = [];
          state.allowInput = true;
          boardEl.style.pointerEvents = "auto";
        }, 520);
      }
    }
  }

  // listeners
  loadPrefs();
  applyAppearance();
  deckSel.addEventListener("change", () => { savePrefs(); });
  sizeSel.addEventListener("change", () => { savePrefs(); });
  modeSel.addEventListener("change", () => { savePrefs(); });

  startBtn.addEventListener("click", startGame);
  restartBtn.addEventListener("click", restartGame);

  winAgainBtn?.addEventListener("click", () => { hideWin(); startGame(); });
  winCloseBtn?.addEventListener("click", hideWin);
  winEl?.addEventListener("click", (e) => { if(e.target === winEl) hideWin(); });
  window.addEventListener("resize", () => {
    if(state){
      computeMetrics(state.size);
    }
  }, { passive: true });

})();
</script>
</body>
</html>
