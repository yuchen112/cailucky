<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Offline Slot (3x3, Stable) v2</title>
  <style>
    :root{
      --bg:#070914;
      --panel:#0f1330;
      --panel2:#0b1026;
      --text:#e8eeff;
      --muted:#a7b4e6;
      --accent:#6aa8ff;
      --good:#6dffb3;
      --warn:#ffd36a;
      --bad:#ff6a8a;

      --shadow: 0 12px 34px rgba(0,0,0,.42);
      --ring: 0 0 0 2px rgba(106,168,255,.25);

      --cell: rgba(255,255,255,.06);
      --cell2: rgba(255,255,255,.12);
      --flash: rgba(106,168,255,.20);

      --gold: rgba(255,211,106,.95);
      --emer: rgba(109,255,179,.95);
      --rose: rgba(255,106,138,.95);
    }

    /* Themes */
    [data-theme="neon"]{
      --bg:#070914; --panel:#0f1330; --panel2:#0b1026;
      --text:#e8eeff; --muted:#a7b4e6; --accent:#6aa8ff;
      --good:#6dffb3; --warn:#ffd36a; --bad:#ff6a8a;
      --cell: rgba(255,255,255,.06); --cell2: rgba(255,255,255,.12);
      --flash: rgba(106,168,255,.20);
    }
    [data-theme="retro"]{
      --bg:#12110f; --panel:#1d1a14; --panel2:#17140f;
      --text:#fff6d8; --muted:#d8caa1; --accent:#ffcc66;
      --good:#9eff7a; --warn:#ffd36a; --bad:#ff7a7a;
      --cell: rgba(255,246,216,.07); --cell2: rgba(255,246,216,.12);
      --flash: rgba(255,204,102,.16);
    }
    [data-theme="mono"]{
      --bg:#0a0a0a; --panel:#141414; --panel2:#101010;
      --text:#f2f2f2; --muted:#bdbdbd; --accent:#d0d0d0;
      --good:#ffffff; --warn:#dcdcdc; --bad:#cfcfcf;
      --cell: rgba(255,255,255,.06); --cell2: rgba(255,255,255,.10);
      --flash: rgba(255,255,255,.10);
    }


    /* Theme-specific machine identities (not just color swaps) */
    [data-theme="neon"] .machine{
      background:
        radial-gradient(120% 90% at 20% 20%, rgba(106,168,255,.10), transparent 60%),
        radial-gradient(90% 70% at 80% 20%, rgba(109,255,179,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-color: rgba(106,168,255,.22);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.03),
        0 0 0 1px rgba(106,168,255,.10),
        0 16px 44px rgba(0,0,0,.45);
    }
    [data-theme="neon"] .reels{
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(106,168,255,.14), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }

    [data-theme="retro"] .machine{
      background:
        radial-gradient(110% 90% at 30% 15%, rgba(255,204,102,.10), transparent 60%),
        radial-gradient(90% 70% at 80% 25%, rgba(255,246,216,.06), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      border-color: rgba(255,204,102,.22);
      box-shadow:
        inset 0 0 0 1px rgba(255,246,216,.04),
        0 0 0 1px rgba(255,204,102,.10),
        0 18px 48px rgba(0,0,0,.48);
    }
    /* stronger CRT scanlines + slight vignette */
    [data-theme="retro"] .reels::after{
      opacity:.48;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,246,216,.00) 0px,
        rgba(255,246,216,.00) 3px,
        rgba(255,246,216,.035) 4px
      );
      mix-blend-mode: overlay;
    }
    [data-theme="retro"] .reelGrid{
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(0,0,0,.30), rgba(0,0,0,.14)),
        linear-gradient(180deg, rgba(255,204,102,.06), rgba(255,204,102,.01));
      border-color: rgba(255,204,102,.18);
    }

    [data-theme="mono"] .machine{
      background:
        radial-gradient(120% 90% at 20% 20%, rgba(255,255,255,.06), transparent 62%),
        radial-gradient(90% 70% at 80% 20%, rgba(255,255,255,.04), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.015));
      border-color: rgba(255,255,255,.14);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.03),
        0 0 0 1px rgba(255,255,255,.06),
        0 18px 52px rgba(0,0,0,.55);
    }
    [data-theme="mono"] .reelGrid{
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(0,0,0,.34), rgba(0,0,0,.18)),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
      border-color: rgba(255,255,255,.14);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 30% 10%, rgba(106,168,255,.12), transparent 55%),
        radial-gradient(900px 650px at 80% 30%, rgba(109,255,179,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      overflow-x:hidden;
    }

    .app{
      width:min(1020px, 100%);
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 920px){ .app{ grid-template-columns: 1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      border-radius:18px;
      overflow:hidden;
      position:relative;
    }

    .header{
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: linear-gradient(180deg, rgba(255,255,255,.07), transparent);
      border-bottom:1px solid rgba(255,255,255,.10);
    }

    .title{
      display:flex; flex-direction:column; gap:4px; min-width:0;
    }
    .title h1{
      margin:0; font-size:16px; letter-spacing:.3px; font-weight:800; line-height:1.2;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .title .sub{
      font-size:12px; color:var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .controlsTop{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
      font-size:12px; color:var(--text);
    }
    .pill label{ color:var(--muted); }
    select{
      background: rgba(0,0,0,.18);
      color: var(--text);
      border:1px solid rgba(255,255,255,.16);
      border-radius:10px;
      padding:7px 10px;
      outline:none;
    }
    select:focus{ box-shadow: var(--ring); }

    .main{ padding:14px; }

    .slotWrap{
      background: linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.06));
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:14px;
      position:relative;
      overflow:hidden;
    }
    .slotWrap::before{
      content:"";
      position:absolute;
      inset:10px;
      border-radius:18px;
      pointer-events:none;
      opacity:.0;
      transition: opacity .25s ease;
    }
    [data-theme="neon"] .slotWrap::before{
      opacity:.95;
      inset:8px;
      border-radius:20px;
      border:2px solid rgba(106,168,255,.22);
      box-shadow:
        0 0 0 1px rgba(106,168,255,.10),
        0 0 24px rgba(106,168,255,.22),
        0 0 52px rgba(109,255,179,.14);
      background:
        linear-gradient(90deg, rgba(106,168,255,.14), rgba(109,255,179,.10), rgba(255,211,106,.10), rgba(255,106,138,.10));
      filter: hue-rotate(0deg);
      animation: neonHue 10.5s linear infinite;
      mix-blend-mode: screen;
    }


    /* Machine frame */
    .machine{
      position:relative;
      border-radius:18px;
      padding:14px;
      background:
        radial-gradient(120% 90% at 20% 20%, rgba(255,255,255,.07), transparent 60%),
        radial-gradient(90% 70% at 80% 20%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      overflow:hidden;
    }

    .lights{
      position:absolute;
      inset:10px;
      border-radius:16px;
      pointer-events:none;
      opacity:.85;
      filter: drop-shadow(0 0 10px rgba(106,168,255,.18));
    }
    
    .lights::before{
  content:"";
  position:absolute;
  inset:-6px;
  border-radius:18px;

  /* Edge LED only (no rotation). */
  background:
    linear-gradient(90deg, rgba(106,168,255,.22), rgba(109,255,179,.14), rgba(255,211,106,.12), rgba(255,106,138,.14), rgba(106,168,255,.22)),
    radial-gradient(closest-side at 20% 25%, rgba(255,255,255,.10), transparent 60%),
    radial-gradient(closest-side at 80% 20%, rgba(255,255,255,.08), transparent 62%),
    radial-gradient(closest-side at 50% 120%, rgba(106,168,255,.14), transparent 65%);

  mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  padding:6px;
  -webkit-mask-composite: xor;
  mask-composite: exclude;

  opacity:.30;
  transform: translateZ(0);
  animation: none;
}

    .lights.idle::before{
      opacity:.30;
      animation: breatheGlow 4.8s ease-in-out infinite;
    }
    [data-theme="neon"] .lights.idle::before{
      animation: breatheGlow 4.8s ease-in-out infinite, neonHue 12s linear infinite;
      transform: rotate(0deg);
    }

    .lights.winS::before{
      opacity:.75;
      animation: winBurst 0.90s ease-out 1;
    }
    .lights.winM::before{
      opacity:.88;
      animation: winBurst 1.05s ease-out 1;
    }
    .lights.winB::before{
      opacity:1;
      animation: winBurst 1.20s ease-out 1;
    }

    @keyframes breatheGlow{
      0%{ opacity:.22; filter: drop-shadow(0 0 8px rgba(106,168,255,.10)); }
      50%{ opacity:.38; filter: drop-shadow(0 0 14px rgba(106,168,255,.18)); }
      100%{ opacity:.22; filter: drop-shadow(0 0 8px rgba(106,168,255,.10)); }
    }
    
    @keyframes neonHue{
      0%{ filter: hue-rotate(0deg); }
      100%{ filter: hue-rotate(360deg); }
    }
@keyframes winBurst{
      0%{ opacity:.0; filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
      20%{ opacity:1; filter: drop-shadow(0 0 18px rgba(255,255,255,.22)); }
      100%{ opacity:.45; filter: drop-shadow(0 0 10px rgba(255,255,255,.14)); }
    }
    @keyframes winSpin{
      0%{ transform: rotate(0deg); }
      100%{ transform: rotate(0deg); }
    }


    .machineFrame{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      position:relative;
      z-index:1;
    }

    .reels{
      width:100%;
      aspect-ratio: 16 / 9;
      min-height: 260px;
      border-radius:16px;
      position:relative;
      padding:12px;
      display:grid;
      place-items:center;
      overflow:hidden;

      background:
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)),
        radial-gradient(80% 70% at 50% 0%, rgba(255,255,255,.08), transparent 70%);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }

    /* subtle scanlines */
    .reels::after{
      content:"";
      position:absolute;
      inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.00) 0px,
        rgba(255,255,255,.00) 4px,
        rgba(255,255,255,.03) 5px
      );
      opacity:.35;
      pointer-events:none;
      mix-blend-mode: overlay;
    }

    .reelGrid{
      width: min(560px, 100%);
      height: min(320px, 100%);
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      padding:12px;
      border-radius:14px;
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(0,0,0,.26), rgba(0,0,0,.12)),
        rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.10);
      position:relative;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.03),
        inset 0 12px 28px rgba(0,0,0,.26);
    }

    .reelCol{
      display:grid;
      grid-template-rows: repeat(3, 1fr);
      gap:10px;
      position:relative;
    }

    /* Reel strip scrolling (true wheel) */
    .reelCol.spinningCol{
      display:block;
      overflow:hidden;
      border-radius:14px;
    }
    .reelCol.spinningCol .reelViewport{
      position:absolute;
      inset:0;
      overflow:hidden;
      border-radius:14px;
    }
    .reelCol.spinningCol .reelStrip{
      position:absolute;
      left:0; right:0; top:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      will-change: transform;
      transform: translateY(0px);
    }
    .reelCol.spinningCol .reelStrip .cell{
      height: calc((100% - 20px) / 3);
      font-size: clamp(18px, 3.2vw, 38px);
    }

    .cell{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.16), transparent 55%),
        linear-gradient(180deg, var(--cell2), var(--cell));
      display:grid;
      place-items:center;
      font-weight:950;
      font-size: clamp(18px, 3.2vw, 38px);
      letter-spacing:.5px;
      text-shadow: 0 2px 10px rgba(0,0,0,.38);
      user-select:none;
      position:relative;
      overflow:hidden;
      transform: translateZ(0);
      transition: filter .12s ease, transform .12s ease;
    }

    /* texture */
    .cell::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.10), transparent 55%),
        repeating-linear-gradient(45deg, rgba(255,255,255,.06) 0, rgba(255,255,255,.06) 2px, rgba(255,255,255,.00) 2px, rgba(255,255,255,.00) 6px);
      opacity:.45;
      pointer-events:none;
      mix-blend-mode: overlay;
    }
    .cell .s{
      position:relative;
      z-index:1;
      display:inline-block;
      padding:2px 4px;
    }

    /* rarity */
    .cell[data-r="low"]{ filter: saturate(.95); }
    .cell[data-r="mid"]{ filter: saturate(1.05) contrast(1.02); }
    .cell[data-r="high"]{
      filter: saturate(1.10) contrast(1.05);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 0 18px rgba(255,211,106,.08);
    }
    .cell[data-r="spec"]{
      filter: saturate(1.10) contrast(1.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.10), 0 0 18px rgba(106,168,255,.10);
    }

    .payline{
      position:absolute;
      left:6%;
      right:6%;
      top: 50%;
      height:4px;
      transform: translateY(-50%);
      background: rgba(255,255,255,.0);
      border-radius:999px;
      box-shadow:none;
      pointer-events:none;
    }
    .payline.on{
      background: rgba(255,255,255,.18);
      box-shadow: 0 0 18px rgba(255,255,255,.18), 0 0 0 1px rgba(255,255,255,.10);
    }

    .hudRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .hudBox{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      min-width: 210px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .hudBox .k{ color:var(--muted); font-size:12px; min-width: 64px; }
    .hudBox .v{ font-size:15px; font-weight:900; letter-spacing:.2px; }
    .hudBox .hint{ font-size:11px; color:var(--muted); margin-left:auto; }

    .betControls{ display:flex; align-items:center; gap:8px; margin-left:auto; }

    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      user-select:none;
      transition: transform .06s ease, filter .12s ease, opacity .12s ease;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; filter: grayscale(.2); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(106,168,255,.34), rgba(106,168,255,.10));
      border-color: rgba(106,168,255,.30);
    }
    .btn.ghost{ background: rgba(255,255,255,.04); }
    .btn.small{ padding:8px 10px; min-width: 44px; }

    .statusBar{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
    }
    .statusText{ font-size:13px; color:var(--text); font-weight:800; letter-spacing:.15px; }
    .statusText .muted{ color:var(--muted); font-weight:800; }
    .winAmt{ font-size:14px; font-weight:950; letter-spacing:.2px; }
    .winAmt.good{ color: var(--good); }
    .winAmt.warn{ color: var(--warn); }
    .winAmt.bad{ color: var(--bad); }

    /* jackpot meter */
    .meterWrap{
      margin-top:12px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .meterTitle{
      font-size:12px; font-weight:900; letter-spacing:.2px;
      color:var(--text);
      display:flex; align-items:center; gap:8px;
    }
    .meterTitle .sub{ color:var(--muted); font-weight:800; }
    .meterBar{
      flex:1;
      min-width: 220px;
      height:12px;
      border-radius:999px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      position:relative;
      box-shadow: inset 0 8px 18px rgba(0,0,0,.20);
    }
    .meterFill{
      height:100%;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(106,168,255,.75), rgba(109,255,179,.75), rgba(255,211,106,.75));
      box-shadow: 0 0 18px rgba(106,168,255,.18);
      position:relative;
      overflow:hidden;
    }
    .meterFill::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, rgba(255,255,255,.0), rgba(255,255,255,.22), rgba(255,255,255,.0));
      transform: translateX(-60%);
      animation: sheen 2.2s ease-in-out infinite;
      opacity:.65;
    }
    @keyframes sheen{
      0%{ transform: translateX(-60%); }
      50%{ transform: translateX(60%); }
      100%{ transform: translateX(120%); }
    }
    .meterValue{
      font-size:12px; color:var(--muted); font-weight:900;
      min-width: 92px;
      text-align:right;
    }

    .side{ padding:14px; display:flex; flex-direction:column; gap:14px; }

    .section{
      padding:14px;
      border-radius:18px;
      background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.10);
    }
    .section h2{ margin:0 0 10px 0; font-size:14px; letter-spacing:.2px; font-weight:900; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .stat .k{ color:var(--muted); font-size:12px; font-weight:800; }
    .stat .v{ font-weight:950; font-size:14px; margin-top:4px; }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    th, td{
      padding:10px 10px;
      text-align:left;
      font-size:12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      font-weight:800;
    }
    th{ color:var(--muted); background: rgba(0,0,0,.16); }
    tr:last-child td{ border-bottom:none; }
    .right{ text-align:right; }

    .howto{
      color:var(--text);
      font-size:12.5px;
      line-height:1.55;
      font-weight:800;
    }
    .howto .muted{ color:var(--muted); font-weight:900; }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-size:12px;
      font-weight:900;
      color:var(--text);
    }
    .badge.good{ border-color: rgba(109,255,179,.28); }
    .badge.warn{ border-color: rgba(255,211,106,.28); }

    /* Overlays */
    .fxOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: transparent;
      z-index: 3;
    }
    .fxOverlay.flash{ animation: flash .38s ease-out 1; }
    @keyframes flash{
      0%{ background: transparent; }
      25%{ background: var(--flash); }
      100%{ background: transparent; }
    }

    canvas#fxCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index: 4;
    }

    /* cell wins */
    .cell.win{
      outline: 2px solid rgba(255,255,255,.22);
      box-shadow: 0 0 22px rgba(255,255,255,.18), inset 0 0 0 1px rgba(255,255,255,.10);
      animation: cellPop .40s ease-out 1;
    }
    @keyframes cellPop{
      0%{ transform: scale(1); filter: brightness(1); }
      35%{ transform: scale(1.07); filter: brightness(1.22); }
      100%{ transform: scale(1); filter: brightness(1.02); }
    }

    /* reel area reactions */
    .reels.bigWin{ animation: bigPulse .55s ease-out 1; }
    @keyframes bigPulse{
      0%{ transform: scale(1); }
      35%{ transform: scale(1.018); }
      100%{ transform: scale(1); }
    }
    .shake{ animation: shake .45s ease-out 1; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      15%{ transform: translateX(-7px); }
      30%{ transform: translateX(7px); }
      45%{ transform: translateX(-5px); }
      60%{ transform: translateX(5px); }
      100%{ transform: translateX(0); }
    }

    /* spinning blur hint */
    .spinning .cell{ filter: blur(.35px) brightness(1.05); }
  
    /* ===== Ultra Spin (120fps-grade) ===== */
    .reelCol.spinningCol .reelStrip{
      transform: translate3d(0,0,0);
      will-change: transform, filter;
      filter: blur(var(--spinBlur, 0px)) brightness(1.06) saturate(1.06);
    }
    .reelCol.spinningCol.spinningFast .reelStrip{
      --spinBlur: 1.15px;
    }
    .reelCol.spinningCol.spinningDecel .reelStrip{
      --spinBlur: .55px;
    }
    .reelCol.spinningCol.spinningStop .reelStrip{
      --spinBlur: 0px;
      filter: blur(0px) brightness(1.02) saturate(1.02);
    }

    /* Fine scanlines only when spinning, to reinforce motion without nausea */
    .reels.spinning::after{ opacity:.42; }

    /* ===== Theme identities: "not just color" ===== */
    .machine{
      isolation:isolate;
    }

    /* Common mechanical details */
    .machine::before,
    .machine::after{
      content:"";
      position:absolute;
      pointer-events:none;
      z-index:0;
    }
    .machine .machineFrame{ z-index:1; position:relative; }

    /* NEON: animated edge LEDs + holographic plate */
    /* NEON: edge LEDs + holographic plate (no rotation, no sweeping rotation) */
[data-theme="neon"] .machine::before{
  inset:-10px;
  border-radius:22px;
  background:
    linear-gradient(90deg,
      rgba(106,168,255,.00),
      rgba(106,168,255,.55),
      rgba(109,255,179,.38),
      rgba(255,211,106,.32),
      rgba(255,106,138,.36),
      rgba(106,168,255,.00)
    );
  filter: blur(10px);
  opacity:.55;
  animation: breatheGlow 4.8s ease-in-out infinite, neonHue 12s linear infinite;
}
[data-theme="neon"] .machine::after{
      inset:8px;
      border-radius:16px;
      background:
        radial-gradient(120% 90% at 15% 15%, rgba(255,255,255,.10), transparent 60%),
        radial-gradient(90% 70% at 85% 18%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(135deg, rgba(106,168,255,.10), rgba(109,255,179,.06), rgba(255,211,106,.06), rgba(255,106,138,.06));
      mix-blend-mode: screen;
      opacity:.32;
    }
    
    /* RETRO: wood cabinet + metal bezel + CRT vignette */
    [data-theme="retro"] .machine{
      border-radius:14px;
    }
    [data-theme="retro"] .machine::before{
      inset:-14px;
      border-radius:18px;
      background:
        linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.12)),
        radial-gradient(120% 120% at 20% 10%, rgba(255,204,102,.14), transparent 62%),
        repeating-linear-gradient(90deg,
          rgba(0,0,0,.00) 0px,
          rgba(0,0,0,.00) 10px,
          rgba(0,0,0,.08) 12px),
        linear-gradient(90deg, #3b2b1b, #5a3f25 35%, #2f2115);
      box-shadow: 0 18px 46px rgba(0,0,0,.55);
      opacity:1;
    }
    [data-theme="retro"] .machine::after{
      inset:10px;
      border-radius:12px;
      background:
        radial-gradient(120% 90% at 50% -10%, rgba(255,246,216,.18), rgba(0,0,0,.00) 55%),
        radial-gradient(90% 90% at 50% 120%, rgba(0,0,0,.28), rgba(0,0,0,.00) 55%),
        linear-gradient(180deg, rgba(255,246,216,.06), rgba(0,0,0,.02));
      opacity:.55;
      mix-blend-mode: overlay;
    }
    [data-theme="retro"] .reels{
      border-radius:12px;
      border-color: rgba(255,204,102,.22);
      box-shadow:
        inset 0 0 0 1px rgba(255,246,216,.05),
        inset 0 18px 36px rgba(0,0,0,.26);
    }
    [data-theme="retro"] .reelGrid{
      border-radius:12px;
      box-shadow:
        inset 0 0 0 1px rgba(255,204,102,.12),
        inset 0 22px 38px rgba(0,0,0,.32);
    }

    /* MONO: brushed metal + gold trim + engraved vibe */
    [data-theme="mono"] .machine{
      border-radius:20px;
    }
    [data-theme="mono"] .machine::before{
      inset:-12px;
      border-radius:26px;
      background:
        radial-gradient(100% 80% at 50% 0%, rgba(255,255,255,.08), rgba(0,0,0,.00) 65%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01)),
        repeating-linear-gradient(135deg,
          rgba(255,255,255,.06) 0px,
          rgba(255,255,255,.06) 1px,
          rgba(0,0,0,.00) 4px,
          rgba(0,0,0,.00) 8px);
      opacity:.75;
      filter: contrast(1.05);
    }
    [data-theme="mono"] .machine::after{
      inset:6px;
      border-radius:16px;
      background:
        linear-gradient(90deg, rgba(255,211,106,.00), rgba(255,211,106,.22), rgba(255,211,106,.00)),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.00));
      opacity:.35;
      mix-blend-mode: screen;
    }
    [data-theme="mono"] .reels{
      border-color: rgba(255,211,106,.20);
      box-shadow:
        inset 0 0 0 1px rgba(255,211,106,.10),
        inset 0 18px 42px rgba(0,0,0,.32);
    }
    [data-theme="mono"] .btn.primary{
      background: linear-gradient(180deg, rgba(255,211,106,.28), rgba(255,211,106,.10));
      border-color: rgba(255,211,106,.28);
    }

  </style>
</head>

<body data-theme="neon">
  <div class="app">
    <div class="card">
      <div class="header">
        <div class="title">
          <h1>ÂñÆÊ©üÊãâÈú∏Ôºà3√ó3Ôºâ</h1>
          <div class="sub">‰∏≠Á∑öÂà§ÂÆöÔΩúWildÔΩúScatter‚ÜíFree SpinsÔΩúÁçéÊ±†Ê¢ùÔºà‰øùÂ∫ïÔºâÔΩúÂèØÈáçÁΩÆ</div>
        </div>

        <div class="controlsTop">
          <div class="pill">
            <label for="themeSel">Ê©üÂè∞‰∏ªÈ°å</label>
            <select id="themeSel" aria-label="Theme">
              <option value="neon">ÈúìËôπÂ§úÂüé</option>
              <option value="retro">Âæ©Âè§Ë°óÊ©ü</option>
              <option value="mono">Ê•µÁ∞°ÈªëÈáë</option>
            </select>
          </div>
          <div class="pill">
            <span class="badge warn" id="fsBadge" style="display:none;">Free SpinsÔºö<span id="fsLeft">0</span></span>
            <span class="badge good" id="multBadge" style="display:none;">ÂÄçÁéáÔºö√ó<span id="multVal">2</span></span>
          </div>
        </div>
      </div>

      <div class="main">
        <div class="slotWrap">
          <div class="machine">
            <div class="lights idle" id="lights"></div>

            <div class="machineFrame">
              <div class="reels" id="reelsArea" aria-label="Reels">
                <div class="fxOverlay" id="fxOverlay"></div>
                <canvas id="fxCanvas"></canvas>

                <div class="reelGrid" id="reelGrid">
                  <div class="payline" id="payline"></div>

                  <div class="reelCol" data-col="0">
                    <div class="cell" id="c0r0"><span class="s">üçí</span></div>
                    <div class="cell" id="c0r1"><span class="s">üçã</span></div>
                    <div class="cell" id="c0r2"><span class="s">üçâ</span></div>
                  </div>
                  <div class="reelCol" data-col="1">
                    <div class="cell" id="c1r0"><span class="s">üîî</span></div>
                    <div class="cell" id="c1r1"><span class="s">üü¶</span></div>
                    <div class="cell" id="c1r2"><span class="s">üü•</span></div>
                  </div>
                  <div class="reelCol" data-col="2">
                    <div class="cell" id="c2r0"><span class="s">7Ô∏è‚É£</span></div>
                    <div class="cell" id="c2r1"><span class="s">üíé</span></div>
                    <div class="cell" id="c2r2"><span class="s">‚≠ê</span></div>
                  </div>
                </div>
              </div>

              <div class="hudRow">
                <div class="hudBox">
                  <div class="k">Balance</div>
                  <div class="v" id="balance">0</div>
                  <div class="hint" id="modeHint">‰∏ÄËà¨</div>
                </div>

                <div class="hudBox">
                  <div class="k">Bet</div>
                  <div class="v" id="bet">0</div>
                  <div class="betControls">
                    <button class="btn small ghost" id="betDown" aria-label="Bet Down">‚àí</button>
                    <button class="btn small ghost" id="betUp" aria-label="Bet Up">Ôºã</button>
                  </div>
                </div>

                <div class="betControls">
                  <button class="btn primary" id="spinBtn">SPIN</button>
                  <button class="btn ghost" id="resetBtn" title="Ê∏ÖÈô§Â≠òÊ™î‰∏¶ÈáçÁΩÆ">ÈáçÁΩÆ</button>
                </div>
              </div>

              <div class="statusBar">
                <div class="statusText" id="statusText">
                  <span class="muted">ÊèêÁ§∫</span>ÔΩúÊåâ SPIN ÊàñÁ©∫ÁôΩÈçµÈñãÂßã„ÄÇ
                </div>
                <div class="winAmt" id="winAmt">Win: 0</div>
              </div>

              <div class="meterWrap">
                <div class="meterTitle">ÁçéÊ±†Ê¢ù <span class="sub">ÔºàÊªø‰∫ÜÁµ¶‰øùÂ∫ïÔºâ</span></div>
                <div class="meterBar" aria-label="Jackpot Meter"><div class="meterFill" id="meterFill"></div></div>
                <div class="meterValue" id="meterValue">0 / 0</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="side">
        <div class="section">
          <h2>Â¶Ç‰ΩïÈÅäÁé©</h2>
          <div class="howto">
            <div>1) Ë™øÊï¥ <b>Bet</b> ‚Üí Êåâ <b>SPIN</b>„ÄÇ</div>
            <div>2) Âè™Âà§ÂÆö <b>‰∏≠Á∑ö</b>Ôºà‰∏≠ÈñìÈÇ£ÊéíÔºâ„ÄÇ</div>
            <div>3) <b>ÂÖ©ÈÄ£</b>ÔºàÂê´ Wild ‰ª£ÊõøÔºâ‰πüÊúÉÁµ¶Â∞èÁçé„ÄÇ</div>
            <div>4) ‰ªªÊÑè‰ΩçÁΩÆÂá∫Áèæ <b>üé∞ Scatter √ó3</b> ‚Üí ÈÄ≤ÂÖ• <b>Free Spins 8 Ê¨°</b>ÔºàÊúüÈñìÁçéÈáë √ó2„ÄÅWild Êõ¥Â∏∏Âá∫Ôºâ„ÄÇ</div>
            <div>5) <b>ÁçéÊ±†Ê¢ù</b> ÊúÉÈö®ÊØèÊ¨°‰∏ãÊ≥®Á¥ØÁ©çÔºåÊªø‰∫ÜÊúÉÁõ¥Êé•Áµ¶‰∏ÄÁ≠Ü <b>‰øùÂ∫ïÁçé</b>„ÄÇ</div>
            <div class="muted" style="margin-top:8px;">Á©∫ÁôΩÈçµ‰πüÂèØ Spin„ÄÇÈáçÁΩÆÊúÉÊ∏ÖÊéâÂ≠òÊ™îÔºàÈ§òÈ°ç„ÄÅÁµ±Ë®à„ÄÅFree Spins„ÄÅÁçéÊ±†Ê¢ùÔºâ„ÄÇ</div>
          </div>
        </div>

        <div class="section">
          <h2>Áµ±Ë®àÔºàÂ≠òÊ™îÔºâ</h2>
          <div class="grid2">
            <div class="stat"><div class="k">Á∏ΩËΩâÊï∏</div><div class="v" id="stSpins">0</div></div>
            <div class="stat"><div class="k">Á∏ΩÊ∑®Êî∂Áõä</div><div class="v" id="stNet">0</div></div>
            <div class="stat"><div class="k">ÊúÄÈï∑ÈÄ£Âãù</div><div class="v" id="stWinStreak">0</div></div>
            <div class="stat"><div class="k">ÊúÄÈï∑ÈÄ£Êïó</div><div class="v" id="stLoseStreak">0</div></div>
            <div class="stat"><div class="k">ÊúÄÂ§ßÂñÆÊ¨°ÂÄçÁéá</div><div class="v" id="stMaxMult">0</div></div>
            <div class="stat"><div class="k">ÊúÄÂ§ßÂñÆÊ¨°ÁçéÈáë</div><div class="v" id="stMaxWin">0</div></div>
          </div>
        </div>

        <div class="section">
          <h2>Ê¥æÂΩ©Ë°®ÔºàÂÄçÁéá √ó BetÔºâ</h2>
          <table>
            <thead>
              <tr><th>Á¨¶Ëôü</th><th class="right">ÂÄçÁéá</th><th>ÂÇôË®ª</th></tr>
            </thead>
            <tbody>
  <tr><td>üçí</td><td class="right">0.8x</td><td>‰ΩéÂÉπ</td></tr>
  <tr><td>üçã</td><td class="right">1.0x</td><td>‰ΩéÂÉπ</td></tr>
  <tr><td>üçâ</td><td class="right">1.2x</td><td>‰ΩéÂÉπ</td></tr>
  <tr><td>üîî</td><td class="right">3x</td><td>‰∏≠ÂÉπ</td></tr>
  <tr><td>üü¶</td><td class="right">4x</td><td>‰∏≠ÂÉπ</td></tr>
  <tr><td>üü•</td><td class="right">5x</td><td>‰∏≠ÂÉπ</td></tr>
  <tr><td>7Ô∏è‚É£</td><td class="right">20x</td><td>È´òÂÉπ</td></tr>
  <tr><td>üíé</td><td class="right">60x</td><td>È´òÂÉπ</td></tr>
  <tr><td>‚≠ê</td><td class="right">15x</td><td>Wild 3 ÈÄ£</td></tr>
  <tr><td colspan="3">ÂÖ©ÈÄ£ÂêåÁ¨¶ËôüÔºàÂê´ WildÔºâ ‚Üí 0.25x</td></tr>
  <tr><td colspan="3">üé∞ Scatter ‰ªªÊÑè‰ΩçÁΩÆ √ó3 ‚Üí Free Spins 8 Ê¨°ÔºàÊúüÈñìÁçéÈáë √ó2„ÄÅWild Á®çÂ¢ûÔºâ</td></tr>
</tbody>
          </table>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const SYM = {
  CH:  { id:"CH",  label:"üçí", rarity:"low"  },
  LE:  { id:"LE",  label:"üçã", rarity:"low"  },
  WA:  { id:"WA",  label:"üçâ", rarity:"low"  },

  BE:  { id:"BE",  label:"üîî", rarity:"mid"  },
  BU:  { id:"BU",  label:"üü¶", rarity:"mid"  },
  RE:  { id:"RE",  label:"üü•", rarity:"mid"  },

  SEV: { id:"SEV", label:"7Ô∏è‚É£", rarity:"high" },
  DIA: { id:"DIA", label:"üíé", rarity:"high" },

  WLD: { id:"WLD", label:"‚≠ê", rarity:"spec" },
  SCT: { id:"SCT", label:"üé∞", rarity:"spec" },
};

  const PAY3 = {
  CH: 0.8,  // üçí
  LE: 1.0,  // üçã
  WA: 1.2,  // üçâ
  BE: 3.0,  // üîî
  BU: 4.0,  // üü¶
  RE: 5.0,  // üü•
  SEV: 20,  // 7Ô∏è‚É£
  DIA: 60,  // üíé
  WLD: 15   // ‚≠ê (3ÈÄ£)
};

  const BETS = [1,2,5,10,20,50];
  const LS_KEY = "offline_slot_v2_stable";
  // Win frequency tuning (reduce "no win" rate a bit by biasing for pairs)
  const PAIR_BIAS_PAID = 0.22; // paid spins: mild bias toward 2-in-a-row / small wins // paid spins: chance a later reel matches an earlier mid symbol
  const PAIR_BIAS_FS   = 0.14; // free spins: a bit lower to keep EV under control // free spins: keep slightly lower to avoid over-paying


  // Jackpot meter (single currency)
  // Each paid spin adds bet * JP_ADD_RATE to meter
  // When meter reaches JP_TARGET, it grants a guaranteed payout: JP_PAY_MULT * bet
  const JP_ADD_RATE = 0.12;           // higher = meter fills faster (more "playability")
  const JP_TARGET_BASE = 120;         // base target; grows slightly with bet
  const JP_TARGET_BET_SCALE = 2.2;    // target = base + bet*scale

  const JP_PAY_MULT = 6;              // guaranteed payout multiplier when meter full
  const JP_PAY_CAP_MULT = 12;         // cap for safety (prevents absurd pay on huge bet tiers)

  const $ = (id) => document.getElementById(id);

  const themeSel = $("themeSel");
  const spinBtn = $("spinBtn");
  const resetBtn = $("resetBtn");
  const betUp = $("betUp");
  const betDown = $("betDown");

  const elBalance = $("balance");
  const elBet = $("bet");
  const elStatus = $("statusText");
  const elWinAmt = $("winAmt");

  const payline = $("payline");
  const reelsArea = $("reelsArea");
  const fxOverlay = $("fxOverlay");
  const lights = $("lights");

  const fsBadge = $("fsBadge");
  const fsLeft = $("fsLeft");
  const multBadge = $("multBadge");
  const multVal = $("multVal");
  const modeHint = $("modeHint");

  const meterFill = $("meterFill");
  const meterValue = $("meterValue");

  const stSpins = $("stSpins");
  const stNet = $("stNet");
  const stWinStreak = $("stWinStreak");
  const stLoseStreak = $("stLoseStreak");
  const stMaxMult = $("stMaxMult");
  const stMaxWin = $("stMaxWin");

  // FX canvas
  const fxCanvas = $("fxCanvas");
  const ctx = fxCanvas.getContext("2d", { alpha: true });

  const cells = [];
  for (let c=0;c<3;c++){
    for (let r=0;r<3;r++){
      cells.push($(`c${c}r${r}`));
    }
  }
  const cellAt = (col,row) => $(`c${col}r${row}`);
  const cellSpan = (col,row) => cellAt(col,row).querySelector(".s");

  // Reel strips (stable-ish; tuned for frequent low symbols, sparse high)
  // Reel strips (true strips; weighted like a real cabinet: plenty of low, some mid, rare high/special)
// Each strip is a loop. The stop index is the MID symbol.
const BASE_STRIPS = [
  [
    "CH","LE","CH","WA","CH","LE","CH","WA","CH","LE","CH","WA",
    "BE","CH","LE","CH","WA","CH","LE","BU","CH","LE","CH","WA",
    "RE","CH","LE","CH","WA","CH","LE","BE","CH","LE","CH","WA",
    "CH","LE","CH","WA","BU","CH","LE","CH","WA","CH","LE","CH",
    "SEV","CH","LE","CH","WA","DIA","CH","LE","CH","WA","SCT","CH",
    "WLD","CH","LE","CH","WA","CH","LE","CH"
  ],
  [
    "LE","CH","WA","CH","LE","WA","CH","LE","WA","CH","LE","WA",
    "BU","CH","LE","WA","CH","LE","BE","CH","LE","WA","CH","LE",
    "RE","CH","LE","WA","CH","LE","BU","CH","LE","WA","CH","LE",
    "CH","WA","CH","LE","BE","CH","LE","WA","CH","LE","WA","CH",
    "SEV","CH","LE","WA","CH","DIA","CH","LE","WA","CH","SCT","LE",
    "WLD","CH","LE","WA","CH","LE","WA","CH"
  ],
  [
    "WA","CH","LE","CH","WA","LE","CH","WA","LE","CH","WA","LE",
    "BE","CH","LE","CH","WA","LE","RE","CH","LE","CH","WA","LE",
    "BU","CH","LE","CH","WA","LE","BE","CH","LE","CH","WA","LE",
    "CH","LE","CH","WA","BU","CH","LE","CH","WA","LE","CH","LE",
    "SEV","CH","LE","CH","WA","DIA","CH","LE","CH","WA","SCT","WA",
    "WLD","CH","LE","CH","WA","LE","CH","WA"
  ]
];

  function getStrip(col, isFreeSpins){
  if (!isFreeSpins) return BASE_STRIPS[col];

  // Free Spins: slightly increase Wild frequency (do not alter Scatter frequency)
  const base = BASE_STRIPS[col];
  const injected = base.slice();

  // Replace a few low symbols with Wild to lift excitement without creating nausea/spam
  const replaceIdx = [5, 17, 29, 41, 55];
  for (const idx of replaceIdx){
    if (injected[idx] && injected[idx] !== "SCT") injected[idx] = "WLD";
  }
  return injected;
}

  function randInt(n){ return Math.floor(Math.random()*n); }

  const defaultState = () => ({
    theme: "neon",
    balance: 1000,
    betIndex: 2,
    freeSpinsLeft: 0,
    pending: null,
    jackpot: { value: 0 },
    stats: {
      spins: 0,
      net: 0,
      winStreak: 0,
      loseStreak: 0,
      bestWinStreak: 0,
      bestLoseStreak: 0,
      maxMult: 0,
      maxWin: 0
    }
  });

  let state = loadState();
  let isSpinning = false;
  let spinTimers = [];
  let reelAnim = { rafIds: [0,0,0], running: false };

  let fx = { particles: [], raf: 0, lastT: 0 };

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return defaultState();
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== "object") return defaultState();
      const s = defaultState();
      return {
        ...s,
        ...obj,
        jackpot: { ...s.jackpot, ...(obj.jackpot||{}) },
        stats: { ...s.stats, ...(obj.stats||{}) }
      };
    }catch(e){
      return defaultState();
    }
  }
  function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }

  function formatNum(n){ return Math.round(n).toString(); }

  function getBet(){ return BETS[state.betIndex]; }

  function jackpotTargetForBet(bet){
    return Math.round(JP_TARGET_BASE + bet * JP_TARGET_BET_SCALE);
  }

  function ensureBetAffordable(){
    if (state.freeSpinsLeft > 0) return;
    if (state.balance >= getBet()) return;
    while (state.betIndex > 0 && state.balance < getBet()) state.betIndex--;
  }

  function setMachineLights(mode){
    lights.classList.remove("idle","winS","winM","winB");
    lights.classList.add(mode);
  }

  function renderAll(){
    document.body.setAttribute("data-theme", state.theme);
    themeSel.value = state.theme;

    ensureBetAffordable();

    const bet = getBet();
    elBalance.textContent = formatNum(state.balance) ;
    elBet.textContent = formatNum(bet);

    if (state.freeSpinsLeft > 0){
      fsBadge.style.display = "";
      multBadge.style.display = "";
      fsLeft.textContent = formatNum(state.freeSpinsLeft);
      multVal.textContent = "2";
      modeHint.textContent = "Free Spins";
      modeHint.style.color = "var(--warn)";
    }else{
      fsBadge.style.display = "none";
      multBadge.style.display = "none";
      modeHint.textContent = "‰∏ÄËà¨";
      modeHint.style.color = "var(--muted)";
    }

    // Jackpot meter
    const target = jackpotTargetForBet(bet);
    const v = Math.max(0, Math.min(target, state.jackpot.value || 0));
    const pct = target > 0 ? (v / target) * 100 : 0;
    meterFill.style.width = pct.toFixed(1) + "%";
    meterValue.textContent = `${formatNum(v)} / ${formatNum(target)}`;

    stSpins.textContent = formatNum(state.stats.spins);
    stNet.textContent = formatNum(state.stats.net);
    stWinStreak.textContent = formatNum(state.stats.bestWinStreak);
    stLoseStreak.textContent = formatNum(state.stats.bestLoseStreak);
    stMaxMult.textContent = state.stats.maxMult ? (state.stats.maxMult.toFixed(1) + "x") : "0";
    stMaxWin.textContent = formatNum(state.stats.maxWin);

    const canSpin = !isSpinning && (state.freeSpinsLeft > 0 || state.balance >= bet);
    spinBtn.disabled = !canSpin;

    betUp.disabled = isSpinning;
    betDown.disabled = isSpinning;
    themeSel.disabled = isSpinning;
  }

  function setStatus(html, win){
    elStatus.innerHTML = html;
    elWinAmt.textContent = "Win: " + formatNum(win);
    elWinAmt.className = "winAmt";
    if (win > 0) elWinAmt.classList.add(win >= getBet()*10 ? "warn" : "good");
    if (win === 0) elWinAmt.classList.add("bad");
  }

  function clearWinHighlights(){
    payline.classList.remove("on");
    for (const el of cells) el.classList.remove("win");
  }

  function flash(){
    fxOverlay.classList.remove("flash");
    void fxOverlay.offsetWidth;
    fxOverlay.classList.add("flash");
  }

  function bigShake(){
    reelsArea.classList.remove("shake");
    void reelsArea.offsetWidth;
    reelsArea.classList.add("shake");
  }

  function bigPulse(){
    reelsArea.classList.remove("bigWin");
    void reelsArea.offsetWidth;
    reelsArea.classList.add("bigWin");
  }

  function highlightMiddleRow(){
    payline.classList.add("on");
    for (let c=0;c<3;c++) cellAt(c,1).classList.add("win");
  }

  function countScatter(result){
    let cnt = 0;
    for (const r of result.reels){
      if (r.top === "SCT") cnt++;
      if (r.mid === "SCT") cnt++;
      if (r.bot === "SCT") cnt++;
    }
    return cnt;
  }

  function symbolMeta(symId){
    const meta = SYM[symId];
    return meta ? meta : { label: symId, rarity:"low" };
  }

  function setCell(col,row,symId){
    const meta = symbolMeta(symId);
    const el = cellAt(col,row);
    el.dataset.r = meta.rarity;
    cellSpan(col,row).textContent = meta.label;
  }

  function setCellsFromResult(result){
    for (let col=0; col<3; col++){
      const r = result.reels[col];
      setCell(col,0, r.top);
      setCell(col,1, r.mid);
      setCell(col,2, r.bot);
    }
  }

  function hasTwoOfKind(line){
    const isWild = (s) => s === "WLD";
    const isScatter = (s) => s === "SCT";
    if (line.some(isScatter)) return false;

    // any pair equal, or one wild pairing any non-scatter
    for (let i=0;i<3;i++){
      for (let j=i+1;j<3;j++){
        const a = line[i], b = line[j];
        if (a === b) return true;
        if (isWild(a) && !isScatter(b)) return true;
        if (isWild(b) && !isScatter(a)) return true;
      }
    }
    return false;
  }

  function evaluatePayout(result){
    const bet = result.bet;
    const isFS = result.isFS;

    const line = [result.reels[0].mid, result.reels[1].mid, result.reels[2].mid];

    const isWild = (s) => s === "WLD";
    const isScatter = (s) => s === "SCT";

    if (line.some(isScatter)){
      return { win: 0, mult: 0, kind: "none" };
    }

    const nonWild = line.filter(s => !isWild(s));
    if (nonWild.length === 0){
      const mult0 = PAY3.WLD;
      const mult = isFS ? mult0*2 : mult0;
      return { win: bet * mult, mult, kind: "3", symbol:"WLD" };
    }

    const uniq = [...new Set(nonWild)];
    if (uniq.length > 1){
      const pairOk = hasTwoOfKind(line);
      if (pairOk){
        const base = 0.2;
        const mult = isFS ? base*2 : base;
        return { win: bet * mult, mult, kind: "2" };
      }
      return { win: 0, mult: 0, kind: "none" };
    }

    const target = uniq[0];
    const baseMult = PAY3[target] ?? 0;
    const mult = isFS ? baseMult*2 : baseMult;
    return { win: bet * mult, mult, kind: "3", symbol: target };
  }

  function generateSpinResult(){
    const isFS = state.freeSpinsLeft > 0;
    const reels = [];

    const bias = isFS ? PAIR_BIAS_FS : PAIR_BIAS_PAID;

    // helper: pick a stop index in `strip` whose mid symbol equals `target`
    const pickStopForMid = (strip, target) => {
      const idxs = [];
      for (let i=0;i<strip.length;i++){
        if (strip[i] === target) idxs.push(i);
      }
      if (!idxs.length) return null;
      return idxs[randInt(idxs.length)];
    };

    for (let col=0; col<3; col++){
      const strip = getStrip(col, isFS);
      const n = strip.length;

      let stop = randInt(n);

      // Slightly reduce "no win" outcomes:
// With some probability, make reel 2/3 align its MID symbol with an earlier reel's MID.
// Guard rails: do NOT bias toward Scatter, and avoid over-biasing into high/special symbols.
if (col > 0 && Math.random() < bias){
  const pickFrom = reels
    .map(x => x.mid)
    .filter(s => s !== "SCT" && s !== "DIA" && s !== "SEV"); // keep big symbols rare
  if (pickFrom.length){
    const targetMid = pickFrom[randInt(pickFrom.length)];
    const forced = pickStopForMid(strip, targetMid);
    if (forced !== null) stop = forced;
  }
}

const top = strip[(stop - 1 + n) % n];
      const mid = strip[stop];
      const bot = strip[(stop + 1) % n];
      reels.push({ top, mid, bot, stop });
    }
    return { ts: Date.now(), isFS, bet: getBet(), reels };
  }

  function clearSpinTimers(){
    for (const t of spinTimers){
      clearInterval(t);
      clearTimeout(t);
    }
    spinTimers = [];
    // cancel reel RAFs if any
    if (reelAnim){
      for (const rid of reelAnim.rafIds){
        if (rid) cancelAnimationFrame(rid);
      }
      reelAnim.rafIds = [0,0,0];
    }
  }

  // FX engine (particles)
  function resizeCanvas(){
    const rect = reelsArea.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    fxCanvas.width = Math.floor(rect.width * dpr);
    fxCanvas.height = Math.floor(rect.height * dpr);
    fxCanvas.style.width = rect.width + "px";
    fxCanvas.style.height = rect.height + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function addParticles(kind, strength){
    // kind: "spark" | "confetti" | "burst"
    const rect = reelsArea.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const cx = w * 0.5, cy = h * 0.45;

    const count =
      kind === "spark" ? Math.round(14 + strength*10) :
      kind === "burst" ? Math.round(26 + strength*18) :
      Math.round(60 + strength*30);

    for (let i=0;i<count;i++){
      const a = Math.random() * Math.PI * 2;
      const sp = (kind === "confetti" ? 120 : 220) + Math.random()* (kind === "spark" ? 120 : 260);
      const vx = Math.cos(a) * sp * (0.5 + Math.random()*0.6);
      const vy = Math.sin(a) * sp * (0.5 + Math.random()*0.6);
      fx.particles.push({
        x: cx + (Math.random()*16-8),
        y: cy + (Math.random()*16-8),
        vx, vy,
        life: 0,
        max: (kind === "confetti" ? 1.2 : 0.8) + Math.random()*0.6,
        size: (kind === "confetti" ? 4 : 2) + Math.random()* (kind === "confetti" ? 6 : 3),
        rot: Math.random()*Math.PI*2,
        vr: (Math.random()*6-3),
        kind,
        hue: (kind === "confetti" ? Math.random()*360 : (200 + Math.random()*70))
      });
    }
    startFxLoop();
  }

  function startFxLoop(){
    if (fx.raf) return;
    fx.lastT = performance.now();
    fx.raf = requestAnimationFrame(tickFx);
  }

  function tickFx(t){
    const dt = Math.min(0.033, (t - fx.lastT) / 1000);
    fx.lastT = t;

    ctx.clearRect(0,0, fxCanvas.width, fxCanvas.height);

    const g = 520; // gravity px/s^2
    const drag = 0.985;

    for (let i=fx.particles.length-1; i>=0; i--){
      const p = fx.particles[i];
      p.life += dt;

      // physics
      p.vx *= drag;
      p.vy = p.vy*drag + g*dt*(p.kind==="confetti" ? 0.85 : 0.55);
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.rot += p.vr*dt;

      const a = 1 - (p.life / p.max);
      if (a <= 0 || p.y > 10000){
        fx.particles.splice(i,1);
        continue;
      }

      // draw
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);

      if (p.kind === "confetti"){
        ctx.globalAlpha = Math.max(0, a*0.95);
        ctx.fillStyle = `hsla(${p.hue}, 90%, 65%, 1)`;
        ctx.fillRect(-p.size*0.6, -p.size*0.3, p.size*1.2, p.size*0.6);
      } else {
        ctx.globalAlpha = Math.max(0, a);
        ctx.fillStyle = `hsla(${p.hue}, 95%, 70%, 1)`;
        ctx.beginPath();
        ctx.arc(0,0, p.size*0.45, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    if (fx.particles.length){
      fx.raf = requestAnimationFrame(tickFx);
    } else {
      fx.raf = 0;
    }
  }

  function animateCountUp(from, to, ms, onUpdate, onDone){
    const start = performance.now();
    const dur = Math.max(180, ms);
    const ease = (x) => 1 - Math.pow(1-x, 3);
    function step(t){
      const p = Math.min(1, (t - start)/dur);
      const v = from + (to - from)*ease(p);
      onUpdate(v);
      if (p < 1) requestAnimationFrame(step);
      else onDone && onDone();
    }
    requestAnimationFrame(step);
  }

  // --- True reel scroll (translateY) ---
  function buildSpinStripSymbols(isFS, finalTop, finalMid, finalBot){
    // Use a weighted pool (mostly low/mid), but keep rare symbols visible sometimes.
        const pool = ["CH","LE","WA","CH","LE","WA","CH","LE","WA","BE","BU","RE","CH","LE","WA","BE","BU","RE","SEV","DIA","WLD","SCT"];
    const baseCount = 84; // ULTRA: longer strip for higher-spec motion
    const arr = [];
    for (let i=0;i<baseCount;i++){
      const sym = pool[randInt(pool.length)];
      arr.push(sym);
    }
    // Ensure last three visible cells are the final result (top/mid/bot)
    arr.push(finalTop, finalMid, finalBot);
    return arr;
  }

  function renderStaticColumn(col, top, mid, bot){
    const colEl = document.querySelector(`.reelCol[data-col="${col}"]`);
    colEl.classList.remove("spinningCol");
    colEl.innerHTML = `
      <div class="cell" id="c${col}r0"><span class="s"></span></div>
      <div class="cell" id="c${col}r1"><span class="s"></span></div>
      <div class="cell" id="c${col}r2"><span class="s"></span></div>
    `;
    setCell(col,0, top);
    setCell(col,1, mid);
    setCell(col,2, bot);
  }

  function renderSpinColumn(col, symbols){
    const colEl = document.querySelector(`.reelCol[data-col="${col}"]`);
    colEl.classList.add("spinningCol");
    colEl.innerHTML = `<div class="reelViewport"><div class="reelStrip"></div></div>`;
    const strip = colEl.querySelector(".reelStrip");

    // Build strip items
    for (const symId of symbols){
      const meta = symbolMeta(symId);
      const item = document.createElement("div");
      item.className = "cell";
      item.dataset.r = meta.rarity;
      item.innerHTML = `<span class="s">${meta.label}</span>`;
      strip.appendChild(item);
    }
    return { colEl, strip };
  }

  function easeOutBack(x){
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3*Math.pow(x-1,3) + c1*Math.pow(x-1,2);
  }

  
  function animateStripTo(stripEl, fromY, toY, durMs, rafSlot, onDone){
    // ULTRA: three-phase inertial motion (accel -> cruise -> spring decel)
    // Designed to feel "high FPS" without inducing nausea.
    const start = performance.now();
    const dur = Math.max(900, durMs);

    // phase weights
    const p1 = 0.18; // accel
    const p2 = 0.54; // cruise
    const p3 = 0.28; // decel

    // easings
    const easeIn = (x) => x*x*(2-x);          // smooth accel
    const easeOut = (x) => 1 - Math.pow(1-x, 3);
    const springOut = (x) => {                // damped spring settle
      const w = 10.5;
      const z = 0.70;
      return 1 - Math.exp(-z*w*x) * (Math.cos(w*x) + (z/Math.sqrt(1-z*z))*Math.sin(w*x));
    };

    const total = toY - fromY;

    function mapProgress(p){
      if (p <= p1){
        const x = p / p1;
        return (easeIn(x) * p1) / (p1 + p2 + p3);
      }
      if (p <= p1 + p2){
        const x = (p - p1) / p2;
        // mostly linear cruise, slightly eased to avoid robotic feel
        return (p1 + (x * p2)) / (p1 + p2 + p3);
      }
      const x = (p - (p1 + p2)) / p3;
      const s = springOut(Math.min(1, x));
      return (p1 + p2 + (s * p3)) / (p1 + p2 + p3);
    }

    function blurFor(p){
      // Stronger blur in accel/cruise, fade out during decel.
      if (p < p1 + p2) return 1.15;
      const x = (p - (p1 + p2)) / p3;
      return Math.max(0, 1.15 * (1 - easeOut(Math.min(1, x))));
    }

    function step(t){
      const raw = Math.min(1, (t - start) / dur);
      const prog = mapProgress(raw);
      const y = fromY + total * prog;

      // apply transform + dynamic blur
      stripEl.style.transform = `translate3d(0, ${y}px, 0)`;
      stripEl.style.setProperty("--spinBlur", blurFor(raw).toFixed(2) + "px");

      if (raw < 1 && reelAnim.running){
        reelAnim.rafIds[rafSlot] = requestAnimationFrame(step);
      } else {
        stripEl.style.transform = `translate3d(0, ${toY}px, 0)`;
        stripEl.style.setProperty("--spinBlur", "0px");
        onDone && onDone();
      }
    }
    reelAnim.rafIds[rafSlot] = requestAnimationFrame(step);
  }

  function startSpinVisual(result){
    const isFS = state.freeSpinsLeft > 0;
    const bet = getBet();

    clearWinHighlights();
    setMachineLights("idle");

    reelsArea.classList.add("spinning");
    setStatus(
      (isFS ? `<span class="muted">Free Spins</span>ÔΩú` : `<span class="muted">‰∏ÄËà¨</span>ÔΩú`)
      + `‰∏ãÊ≥® <b>${bet}</b>ÔºåËΩâÂãï‰∏≠‚Ä¶`,
      0
    );

    isSpinning = true;
    reelAnim.running = true;
    clearSpinTimers();
    renderAll();

    // Column stop timings (left -> mid -> right)
    const stopDur = [1180, 1380, 1580]; // ULTRA ms (longer travel, smoother feel)
    const stopGap = [0, 140, 280];    // ULTRA sequencing (keeps tempo)

    let stopped = 0;

    for (let col=0; col<3; col++){
      const r = result.reels[col];

      const symbols = buildSpinStripSymbols(isFS, r.top, r.mid, r.bot);
      const { colEl, strip } = renderSpinColumn(col, symbols);
      colEl.classList.add('spinningFast');
      colEl.classList.remove('spinningDecel','spinningStop');

      // Measure sizes
      const viewport = strip.parentElement;
      const firstCell = strip.querySelector(".cell");
      const cellH = firstCell ? firstCell.getBoundingClientRect().height : 60;
      const gap = 10; // matches CSS gap
      const stepH = cellH + gap;

      // total strip height approximation
      const stripItems = symbols.length;
      const stripH = stripItems * stepH - gap;
      const viewH = viewport.getBoundingClientRect().height;

      // Target so that the LAST 3 items are visible (finalTop/finalMid/finalBot)
      const targetY = -(stripH - viewH);

      // Start from slightly above so it feels like a continuous wheel
      const startY = 0;

      // Kick animation with slight stagger
      const t = setTimeout(() => {
        // add a tiny pre-nudge for "accel" feel
        strip.style.transform = `translateY(${startY}px)`;
        const decelT = setTimeout(() => {
          colEl.classList.remove('spinningFast');
          colEl.classList.add('spinningDecel');
        }, Math.max(0, stopDur[col] - 240));
        spinTimers.push(decelT);

        animateStripTo(strip, startY, targetY, stopDur[col], col, () => {
          // Restore static 3x3 cells for evaluation/highlight
          colEl.classList.remove('spinningFast','spinningDecel');
          colEl.classList.add('spinningStop');
          renderStaticColumn(col, r.top, r.mid, r.bot);

          flash();
          stopped++;
          if (stopped >= 3){
            reelAnim.running = false;
            // Settle after the last reel stops (small delay for feel)
            const settleT = setTimeout(() => { endSpinAndSettle(); }, 120);
            spinTimers.push(settleT);
          }
        });
      }, stopGap[col]);
      spinTimers.push(t);
    }
  }

  function applyJackpotProgress(bet){
    const target = jackpotTargetForBet(bet);
    const add = Math.max(1, Math.round(bet * JP_ADD_RATE));
    state.jackpot.value = Math.max(0, (state.jackpot.value || 0) + add);

    // if full -> pay guaranteed
    if (state.jackpot.value >= target){
      state.jackpot.value = 0;
      // guaranteed payout based on bet
      const mult = Math.min(JP_PAY_CAP_MULT, JP_PAY_MULT + Math.floor(bet/20));
      return { triggered: true, mult, win: bet * mult };
    }
    return { triggered: false, mult: 0, win: 0 };
  }

  function endSpinAndSettle(){
    clearSpinTimers();
    reelsArea.classList.remove("spinning");

    const result = state.pending;
    if (!result){
      isSpinning = false;
      renderAll();
      setStatus("ÁãÄÊÖãÁï∞Â∏∏Â∑≤Ëá™Êàë‰øÆÂæ©ÔºåË´ãÂÜçË©¶‰∏ÄÊ¨°„ÄÇ", 0);
      return;
    }

    setCellsFromResult(result);

    const bet = result.bet;
    const scatterCnt = countScatter(result);

    let fsAward = 0;
    if (scatterCnt >= 3) fsAward = 8;

    const evalRes = evaluatePayout(result);
    let win = evalRes.win;
    let mult = evalRes.mult;

    // Jackpot meter only on paid spins (not free spins)
    let jp = { triggered:false, mult:0, win:0 };
    if (!result.isFS){
      jp = applyJackpotProgress(bet);
      if (jp.triggered){
        win += jp.win;
      }
    }

    clearWinHighlights();

    // message parts
    const parts = [];
    if (scatterCnt >= 3){
      parts.push(`üé∞ Scatter √ó${scatterCnt} ‚Üí Free Spins <b>${fsAward}</b> Ê¨°`);
    }
    if (jp.triggered){
      parts.push(`ÁçéÊ±†‰øùÂ∫ï <b>${jp.mult}x</b>`);
    }

    // Visual tiering
    let tier = "none"; // none | small | mid | big
    if (win > 0){
      highlightMiddleRow();
      if (mult >= 30 || jp.mult >= 10) tier = "big";
      else if (mult >= 10 || jp.mult >= 6) tier = "mid";
      else tier = "small";
    }

    if (win > 0){
      if (tier === "small"){
        setMachineLights("winS");
        flash();
        addParticles("spark", 0.3);
      } else if (tier === "mid"){
        setMachineLights("winM");
        bigPulse();
        flash();
        addParticles("burst", 0.6);
      } else {
        setMachineLights("winB");
        bigShake();
        bigPulse();
        flash();
        addParticles("confetti", 1.0);
      }
    } else {
      setMachineLights("idle");
    }

    // Balance delta
    let delta = 0;
    if (!result.isFS){
      state.balance -= bet;
      delta -= bet;
    } else {
      state.freeSpinsLeft = Math.max(0, state.freeSpinsLeft - 1);
    }

    const winRounded = Math.round(win || 0);
    if (winRounded > 0){
      state.balance += winRounded;
      delta += winRounded;
    }

    if (fsAward > 0){
      state.freeSpinsLeft += fsAward;
    }

    // stats
    state.stats.spins += 1;
    state.stats.net += delta;

    if (winRounded > 0){
      state.stats.winStreak += 1;
      state.stats.loseStreak = 0;
      state.stats.bestWinStreak = Math.max(state.stats.bestWinStreak, state.stats.winStreak);
    }else{
      state.stats.loseStreak += 1;
      state.stats.winStreak = 0;
      state.stats.bestLoseStreak = Math.max(state.stats.bestLoseStreak, state.stats.loseStreak);
    }

    state.stats.maxMult = Math.max(state.stats.maxMult, (mult || 0), (jp.mult || 0));
    state.stats.maxWin = Math.max(state.stats.maxWin, winRounded);

    state.pending = null;

    ensureBetAffordable();
    saveState();

    // Status & count-up win display (more satisfying)
    const modeTxt = (state.freeSpinsLeft > 0) ? `<span class="muted">Free Spins</span>` : `<span class="muted">‰∏ÄËà¨</span>`;
    const deltaTxt = delta >= 0
      ? `<span style="color:var(--good);font-weight:950;">+${formatNum(delta)}</span>`
      : `<span style="color:var(--bad);font-weight:950;">${formatNum(delta)}</span>`;

    if (winRounded > 0){
      let label = tier === "big" ? "Â§ßÁçé" : (tier === "mid" ? "‰∏≠Áçé" : "Â∞èÁçé");
      const multTxt = mult ? `${mult.toFixed(1)}x` : "";
      const msg = `${modeTxt}ÔΩú${label}${multTxt ? ` <b>${multTxt}</b>` : ""}${parts.length ? `ÔΩú${parts.join("ÔΩú")}` : ""}ÔΩúÊú¨Ê¨°ËÆäÂãï ${deltaTxt}`;
      setStatus(msg, winRounded);

      // Count-up feel on Win display
      const from = 0;
      const to = winRounded;
      const ms = tier === "big" ? 820 : (tier === "mid" ? 520 : 320);
      animateCountUp(from, to, ms, (v) => {
        const vv = Math.max(0, Math.round(v));
        elWinAmt.textContent = "Win: " + formatNum(vv);
      });
    } else {
      const msg = `${modeTxt}ÔΩúÊú™‰∏≠Áçé${parts.length ? `ÔΩú${parts.join("ÔΩú")}` : ""}ÔΩúÊú¨Ê¨°ËÆäÂãï ${deltaTxt}`;
      setStatus(msg, 0);
    }

    isSpinning = false;
    renderAll();
  }

  function spin(){
    if (isSpinning) return;

    ensureBetAffordable();

    const bet = getBet();
    const canSpin = (state.freeSpinsLeft > 0) || (state.balance >= bet);
    if (!canSpin){
      setStatus("È§òÈ°ç‰∏çË∂≥ÔºåÂ∑≤Ëá™Âãï‰∏ãË™ø‰∏ãÊ≥®‰ªç‰∏çË∂≥„ÄÇË´ãÈáçÁΩÆÊàñÊèêÈ´òÂàùÂßãÈ§òÈ°ç„ÄÇ", 0);
      renderAll();
      return;
    }

    const result = generateSpinResult();
    state.pending = result;
    saveState();

    startSpinVisual(result);
  }

  function hardReset(){
    state = defaultState();
    saveState();
    renderAll();
    setMachineLights("idle");
    setStatus(`<span class="muted">ÊèêÁ§∫</span>ÔΩúÂ∑≤ÈáçÁΩÆÂ≠òÊ™î„ÄÇÊåâ SPIN ÊàñÁ©∫ÁôΩÈçµÈñãÂßã„ÄÇ`, 0);
  }

  function recoverIfPending(){
    if (!state.pending) return;
    setCellsFromResult(state.pending);
    setStatus(`<span class="muted">ÊèêÁ§∫</span>ÔΩúÂÅµÊ∏¨Âà∞Êú™ÁµêÁÆóÁµêÊûúÔºåÂ∑≤Ëá™ÂãïÁµêÁÆó„ÄÇ`, 0);
    Promise.resolve().then(() => {
      isSpinning = true;
      endSpinAndSettle();
    });
  }

  // events
  themeSel.addEventListener("change", () => {
    state.theme = themeSel.value;
    saveState();
    renderAll();
  });

  betUp.addEventListener("click", () => {
    if (isSpinning) return;
    state.betIndex = Math.min(BETS.length - 1, state.betIndex + 1);
    ensureBetAffordable();
    saveState();
    renderAll();
  });

  betDown.addEventListener("click", () => {
    if (isSpinning) return;
    state.betIndex = Math.max(0, state.betIndex - 1);
    saveState();
    renderAll();
  });

  spinBtn.addEventListener("click", spin);

  resetBtn.addEventListener("click", () => {
    if (isSpinning) return;
    if (confirm("Á¢∫ÂÆöË¶ÅÈáçÁΩÆÂ≠òÊ™îÔºüÔºàÈ§òÈ°ç„ÄÅÁµ±Ë®à„ÄÅFree Spins„ÄÅÁçéÊ±†Ê¢ù ÈÉΩÊúÉÊ∏ÖÈô§Ôºâ")){
      hardReset();
    }
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === " "){
      e.preventDefault();
      spin();
    }
  });

  // init
  function initPreview(){
  const preview = {
    isFS:false,
    bet: getBet(),
    reels: [
      { top:"CH", mid:"LE", bot:"WA" },
      { top:"BE", mid:"BU", bot:"RE" },
      { top:"SEV", mid:"DIA", bot:"WLD" }
    ]
  };
  setCellsFromResult(preview);
}

  window.addEventListener("resize", () => { resizeCanvas(); });

  resizeCanvas();
  renderAll();
  if (!state.pending) initPreview();
  setMachineLights("idle");
  setStatus(`<span class="muted">ÊèêÁ§∫</span>ÔΩúÊåâ SPIN ÊàñÁ©∫ÁôΩÈçµÈñãÂßã„ÄÇ`, 0);

  recoverIfPending();
})();
</script>
</body>
</html>
